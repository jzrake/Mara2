\documentclass{article}
\usepackage{listings}
\usepackage{graphicx}

\title{Primer on Mara Computational Library}
\author{Andrew Liu \and Jonathan Zrake}

\begin{document}
\maketitle

\section{Introduction and Software Architecture}
\subsection{Background}
The objective of this primer is to introduce the main ideas of Mara and its funtionality in a relatively self-contained manner. 

Mara is a multidimensional Godunov-type code that solves the equations of
compressible gasdynamics and magnetohydrodynamics (MHD). (add link in footnotes or cite: https://github.com/jzrake/Mara2). Source code and visualization python modules available for pull request.

Let's examine the basic structure of the program:
\begin{itemize}
	\item To begin the simulation, type: 

	\texttt{./mara PROGRAM\_NAME PARAMETERS}

	sample command:

\texttt{./mara convect N=100 tfinal=100 cpi=0.25}
	
in the command line; \texttt{PROGRAM\_NAME} is the key name corresponding to key-value pairs listed in Mara.cpp inside int main block. All of the key-value pairs are specified as: 

\texttt{programs["regress-1d"]=std::make\_unique<Hydro1DTestProgram>()}

Please note \texttt{programs[...]} is a c++ \texttt{std::map} containing unique pointers to Mara programs, more on that later. Sample input include: \texttt{regress-1d}, \texttt{raid}, \texttt{pinch}, \texttt{kinetic}, \texttt{convect}.

	\item Run-time parameters can be specified in typical unix command format. For example, to specify the number of gridpoints used in a hydrodynamic simulation, \texttt{PARAMETERS} can include \texttt{N=1000}, representing 1000 gridpoints in the mesh, or \texttt{tfinal=100}, thereby setting the final physical time to 100s.  
	
	\item Simulation results will be regularly stored in checkpoints in \texttt{./Mara/data} subdirectory. The interval of saving down checkpoints can be specified in the run-time parameters described above; \texttt{cpi=xxx}. xxx being the physicaltime interval you want between written checkpoints.
	

\end{itemize}


\subsection{Architecture: in the context of ThermalConvection.cpp}
\begin{itemize}
	\item Mara files are modular, with the physics related files containing numerical scheme implementations, Mesh implementation of different geometries (Cartesian/Spherical), stored in \texttt{./Mara/src/Problems/}. 
	
	\item Coded-up sample problems are stored in \texttt{./Mara/src/}
	
	\item Convenience or helper functions and general housekeeping code that ensures Mara runs smoothly are written in Cow; source code located in \texttt{./Mara/Cow/src/}, more on that in the next section
	
	\item The command-line arguments are passed into mara.cpp main in the usual \texttt{int argc, const char* argv[]} manner
	
	\item As mentioned above, the \texttt{program} map parses the command-line, looking for valid program names
	
	\item If valid program name found, it runs the program through the run function specified in the individual program files. Example: \texttt{int ThermalConvectionProgram::run (int argc, const char* argv[])} in ThermalConvection.cpp.

	\item Problem Customization Settings:
		
	\begin{itemize}
		\item Code contained within program files are particular configurations of a problem. For example, looking at ThermalConvection.cpp, one can specify a particular \texttt{ sourceTermsFunction}, which is a lambda which takes 3 spatial coordinates and an empty 5 component array (1 density, 3 momenta, 1 energy) containing the source terms at each specific cell gridpoint. With source term meaning the RHS of the set of Euler eq:
	
	$$\frac{\partial \textbf{(density)}}{\partial t} + \nabla \cdot \textbf{flux} = \textbf{source}$$
	
	This allows flexibility to customize simulations on any sources.
	
		\item Another important feature is the \texttt{initialData} lambda: the main use is to specify initial conditions. Notice \texttt{const double rho = 1.0;}. The initial profile of the gas is set to 1.0, and uniform across all the grid cells. We can also, customize \texttt{rho} to be any parametrizable function. A good example would be the hydrostatic profile. 
		
	\end{itemize}		
	
	
	\item The problem file also assigns a few important pointers to important objects which are later used in the program (specifics of each are discussed in the next section). Generally speaking, pointers to mesh operators (\texttt{mo}), field operators (\texttt{fo}) and mesh data (\texttt{md}) (very important this one!) will be assigned.
	
	\item Mesh Customization Settings:
	\begin{itemize}	
		\item Perhaps the core of the simulation is the mesh geometry (\texttt{mg})--whether cartesian or spherical is specified. \texttt{mg->setCellsShape} is used to set number of meshpoints in each direction while \texttt{mg->setLowerUpper} is used to set range in each dimension respectively. Pointer to mesh geometry, for example, can be changed to \texttt{auto mg = std::shared\_ptr<MeshGeometry> (new SphericalMeshGeometry)} to accomodate different geometries.
		
		\item Boundary cells are taken into account through \texttt{bs = Shape \{\{ 2, 0, 0, 0, 0 \}\}} (\texttt{bs} for boundary shape) for example. This array format will be discussed more in detail. But the main idea is that there are 2 ``ghost cells" in the 1st-direction (x in cartesian) and none for the other 2nd and 3rd direction. Ignore the 4th and 5th 0's for now--they will mean something later. 
		
		\item Once boundary cells are set, we can take care of the rest of the boundary conditions through the problem-specific \texttt{apply} method. Each problem contains it's own inherited BC class, \\
	e.g. \texttt{class ThermalConvectionBoundaryCondition:public BoundaryCondition}. The apply method can override it's parent's \texttt{apply} and can customize BC specifications tailored to the problem. E.g. reflecting/outflow/inflow... boundary conditions at either endpoint (or write one yourself!)   
		
		\item This boundary shape array, along with the appropriate number of conserved variables and the geometry are passed into this \textbf{mesh data constructor}: \texttt{auto md = std::make\_shared<MeshData> (mg->cellsShape(), bs, cl->getNumConserved());}, which initializes the mesh on which numerical simulations will be done. It's important for the program to know how many conserved variables there are to allocate the right amount of memory for the mesh/primitive arrays.		
		
	\end{itemize}
	
	
	\item Scheduler and logger are pointers passed into \texttt{maraMainLoop} in Mara.cpp. Scheduler arranges tasks to be performed in sequence and logger cout's essential output when simulation run. 
	
	\item The writer then writes the data before returning maraMainLoop.
	
	\item Logger is for performing \texttt{std::cout} into our console 
	
	\item The program file ends with: \texttt{return maraMainLoop (status, timestep, condition, advance, *scheduler, *logger)}, the first 4 arguments are callback lambdas defined above in the program and the last two are dereferenced scheduler and logger pointers which allow allocated memory to persist in between loop.
	
	\item \texttt{maraMainLoop} loops over time and advances the simulation forward in time according to \texttt{advance} lambda and exits when \texttt{condition} lambda becomes false.
	
	\item \underline{A common misconception} is to think that program files do all the heavy-lifting computations in one file. Instead, the iterations forward in time is done when the program file returns to Mara.cpp, where computations are advanced until simulations are completed. The time-step integrator can be specified in the individual program files through \texttt{ss=std::make\_shared<MethodOfLinesTVD>} member functions. (\texttt{ss} short for solution scheme). Important \texttt{ss} member function include \texttt{ss->setBoundaryCondition(bc) and ss->setRungeKuttaOrder(2)} for starters. And a few important housekeeping member functions to ensure the correct mesh and field operator are specified \texttt{ss->setMeshOperator(mo); ss->setFieldOperator(fo)}.

\end{itemize}

Now that we've covered the basic flow of the program, we can delve deeper into the details of Cow and Mara modules and its syntax.

\section{Review on Cow}
\subsection{Array}

Mara uses a bit of abbrevations when referencing Cow modules which could be hard to keep track of at times. We list the commonly used ones:

\begin{itemize}
	\item \texttt{using Shape=std::array<int,5>;
} 
	\item \texttt{using Index=std::array<int,5>;}
	\item \texttt{using using Array=Cow::Array}
	\begin{itemize}
		\item Array-type constructor can be Shape: using Shape = array<int,5>
		\item Array constructor takes \texttt{\{n1, n2, n3, n4, n5\}}
, Cow then computes n1*n2*n3*n4*n5*sizeof(double) and allocates that in memory 
		\item Important thing to note is if Array \{\{100,1,1,5,1\}\}, then Array.size()=100*1*1*5*1=500
		\item Some useful short-hand: \texttt{P(i,j,k,q,l)} will get direct access to the memory of a 5-dimensional (nested) array at \texttt{P[i][j][k][q][l]}
		\item if \texttt{P(i,j,k)} then get direct access to \texttt{P(i,j,k,0,0)}
		\item The notation to initialize Cow::Arrays is {{n1,n2,n3,n4,n5}}, where n1,n2,n3 are dimenions (of a grid usually) in direction 1,2 and 3 of your system. n4 is usually the number of primitives/conserved variables your system has. In classical hydrodynamics, n4=5. n5 is the so-called rank, which tells us for each primitive variable at a point on a mesh, how many components that primitive variable has. For Newtonian hydrodynamics rank is 1 since mass density/ total energy density is a scalar function and momentum1 density is also a scalar since we split each direction up into 3 equations, so n5 is 1. 
		\item Now to apply this idea of a 5 dimensional array, as mentioned above, since numComponent in our hydrodynamic case in \texttt{ThermalConvection.cpp} is 5. If location \texttt{i,j,k} are specified within the grid, then P(i,j,k,0-4,0) contain the 5 primitive variables and is a 5 component 1D array (or a vector) corresponding to the primitive in at cell:i,j,k.
		\item P[Region] is how one references/retrieves information from an array, where region contains strided region (discussed below).
		\item Shape3D is a helper class to make sure 3 component arrays return 5 component arrays
		\item Shape3D(5-dim-Array) => 5 component array
		\item 5 component array is {1,2,3,4,5}, 5 diminension array is A[][][][][], note the difference
		\item if you pass 5 component array into Shape3D, private variable S is filled with the components, S is 5 component as well
		\item begin() and end() methods works for Array, and gives iterator taking into account strides.
	\end{itemize}
	\item Region
	\begin{itemize}
		\item Empty region has no stride: lower=0, upper=0, stride=0. lower and upper are respectively the lower and upper index of a region. It can be positive or negative. Positive means it's an absolute region, negative or zero means index from that end (python-like notation when dealing with arrays). 
		\item A natural region has stride 1: lower=0, upper=0, stride=1.
		\item A region literally describes a region with lower,upper,stride within an array, that's why this concept is natural. It is also important to consider stride, lower and upper because of how memory is allocated. 
		\item One useful method in Array class is Array[Region] which returns a reference to the region you specified
	\end{itemize}
	\item Range
	\begin{itemize}
		\item Like a 1-dimensional analog of Region where only concerned with 1 axis within an array

	\end{itemize}
\end{itemize}

\subsection{Variant}
This is a section 

\section{Mara}
This is a section 

\subsection{Mara}
This is a section 

\subsection{MeshData}
This is a section 

\subsection{BoundaryConditions}
This is a section 

\subsection{ConservationLaws}
This is a section 

\subsection{FieldOperator}
\begin{itemize}
	\item Field operators on the other hand perform operators on the primitive/conserved variables. This module includes convenience functions like \texttt{getConservationLaw()} which returns a shared pointer to the conservation law used. Other convenience functions include converting primitive variable arrays into conserved variables via \texttt{void generateConserved (Array::Reference P, Array::Reference U) const} which takes an array containing primitives P and puts the conserved variables into an empty array U. Courant timesteps are computed here as well. Perhaps an important diagnostic tool for sanity-checking the evolution of density-like thermodynamic quantities (i.e. entropy or total energy $e_T=e+\frac{1}{2}\rho v^2$, $e$ is the internal energy per unit volume) or momentum density in 3 dimensions $\rho \vec{v}$ in the Euler equations, is the \texttt{std::vector<double> volumeIntegratedDiagnostics (Array::Reference P, Array::Reference V) const} function. This returns volume integral (not volume average) of named diagnostics which are defaulted to `total\_energy' or 'mass' but one can customize this to ensure code is giving sensible results, \textbf{P and V contain primitives and cell volume for individual grid cells respectively throughout the whole mesh.} 
\end{itemize}

\subsection{MeshOperator}
\begin{itemize}
	\item Mesh operators are operators which Mara performs on the mesh grid itself (just spatial dimensions, doesn't touch primitive/conserved data in each cell). Common member functions include \texttt{divergence} and {curl}. One important one is \texttt{measure}, which returns the 1, 2, or 3 dimensional measure of the given mesh locations: length of edges, area of faces, or volume of cells. \textbf{ Can talk about generate or generate Sourceterms HERE!!!!!!!!!!!}
\end{itemize}

\subsection{Scheduler}
\begin{itemize}
	\item Scheduler and logger are pointers that are passed through back into the maraMainLoop in the Mara.cpp file. Main function of scheduler is to put together a list of tasks to be completed at certain points when the code runs. They could include writing checkpoints or saving down time series data to ensure code is running properly and thereby optimizing data retrieval. An example of scheduler is \texttt{scheduler->schedule (taskTimeSeries, TaskScheduler::Recurrence (user["tsi"]), "time\_series");}. \texttt{taskTimeSeries} is a callback lambda which the function takes as input, thereby telling the scheduler what function to use to perform a specific task at certain periods of time during runtime. What determines \emph{when} the task is performed depends solely on the \textbf{recurrence rule}. This literally means, when will the task/function recurr in the program via some hard and fast rule. In this case, \texttt{TaskScheduler::Recurrence (user["tsi"])} does just that using \texttt{user["tsi"]} which is specified at runtime. \textbf{SPLIT LOGGER INTO SEPARATE PARAGRAPH}
\end{itemize}


\subsection{Problems}
This is a section 

\subsection{RiemannSolvers}
This is a section 

\subsection{SolutionSchemes}
This is a section 









\end{document}