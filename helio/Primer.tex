\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
%\usepackage[legalpaper, margin=1in]{geometry}



\title{Primer on Mara Computational Library}
\author{Andrew Liu \and Jonathan Zrake}

\begin{document}
\maketitle

\section{Introduction and Software Architecture}
\subsection{Background}
The objective of this primer is to introduce the main ideas of Mara and its funtionality in a relatively self-contained manner. The goal is to make Mara's structure tractable and to point out the most important modules for basic computation.

Mara is a multidimensional Godunov-type code that solves the equations of
compressible gasdynamics and magnetohydrodynamics (MHD). (add link in footnotes or cite: https://github.com/jzrake/Mara2). Source code and visualization python modules available for pull request.

Let's examine the basic structure of the program:
\begin{itemize}
	\item To begin the simulation, type: 

	\texttt{./mara PROGRAM\_NAME PARAMETERS}

	sample command:

\texttt{./mara convect N=100 tfinal=100 cpi=0.25}
	
in the command line; \texttt{PROGRAM\_NAME} is the key name corresponding to key-value pairs listed in Mara.cpp inside int main block. All of the key-value pairs are specified as: 

\texttt{programs["regress-1d"]=std::make\_unique<Hydro1DTestProgram>()}

Please note \texttt{programs[...]} is a c++ \texttt{std::map} containing unique pointers to Mara programs, more on that later. Sample input include: \texttt{regress-1d}, \texttt{raid}, \texttt{pinch}, \texttt{kinetic}, \texttt{convect}.

	\item Run-time parameters can be specified in typical unix command format. For example, to specify the number of gridpoints used in a hydrodynamic simulation, \texttt{PARAMETERS} can include \texttt{N=1000}, representing 1000 gridpoints in the mesh, or \texttt{tfinal=100}, thereby setting the final physical time to 100s.  
	
	\item Simulation results will be regularly stored in checkpoints in \texttt{./Mara/data} subdirectory. The interval of saving down checkpoints can be specified in the run-time parameters described above; \texttt{cpi=xxx}. xxx being the physicaltime interval you want between written checkpoints.
	

\end{itemize}


\subsection{Architecture: in the context of ThermalConvection.cpp}
\begin{itemize}
	\item Mara files are modular, with the physics related files containing numerical scheme implementations, Mesh implementation of different geometries (Cartesian/Spherical), stored in \texttt{./Mara/src/Problems/}. 
	
	\item Coded-up sample problems are stored in \texttt{./Mara/src/}
	
	\item Convenience or helper functions and general housekeeping code that ensures Mara runs smoothly are written in Cow; source code located in \texttt{./Mara/Cow/src/}, more on that in the next section
	
	\item The command-line arguments are passed into mara.cpp main in the usual \texttt{int argc, const char* argv[]} manner
	
	\item As mentioned above, the \texttt{program} map parses the command-line, looking for valid program names
	
	\item If valid program name found, it runs the program through the run function specified in the individual program files. Example: \texttt{int ThermalConvectionProgram::run (int argc, const char* argv[])} in ThermalConvection.cpp.

	\item Problem Customization Settings:
		
	\begin{itemize}
		\item Code contained within program files are particular configurations of a problem. For example, looking at ThermalConvection.cpp, one can specify a particular \texttt{ sourceTermsFunction}, which is a lambda which takes 3 spatial coordinates and an empty 5 component array (1 density, 3 momenta, 1 energy) containing the source terms at each specific cell gridpoint. With source term meaning the RHS of the set of Euler eq:
	
	$$\frac{\partial \textbf{(density)}}{\partial t} + \nabla \cdot \textbf{flux} = \textbf{source}$$
	
	This allows flexibility to customize simulations on any sources.
	
		\item Another important feature is the \texttt{initialData} lambda: the main use is to specify initial conditions. Notice \texttt{const double rho = 1.0;}. The initial profile of the gas is set to 1.0, and uniform across all the grid cells. We can also, customize \texttt{rho} to be any parametrizable function. A good example would be the hydrostatic profile. 
		
	\end{itemize}		
	
	
	\item The problem file also assigns a few important pointers to important objects which are later used in the program (specifics of each are discussed in the next section). Generally speaking, pointers to mesh operators (\texttt{mo}), field operators (\texttt{fo}) and mesh data (\texttt{md}) (very important this one!) will be assigned.
	
	\item Mesh Customization Settings:
	\begin{itemize}	
		\item Perhaps the core of the simulation is the mesh geometry (\texttt{mg})--whether cartesian or spherical is specified. \texttt{mg->setCellsShape} is used to set number of meshpoints in each direction while \texttt{mg->setLowerUpper} is used to set range in each dimension respectively. Pointer to mesh geometry, for example, can be changed to \texttt{auto mg = std::shared\_ptr<MeshGeometry> (new SphericalMeshGeometry)} to accomodate different geometries.
		
		\item Boundary cells are taken into account through \texttt{bs = Shape \{\{ 2, 0, 0, 0, 0 \}\}} (\texttt{bs} for boundary shape) for example. This array format will be discussed more in detail. But the main idea is that there are 2 ``ghost cells" in the 1st-direction (x in cartesian) and none for the other 2nd and 3rd direction. Ignore the 4th and 5th 0's for now--they will mean something later. 
		
		\item Once boundary cells are set, we can take care of the rest of the boundary conditions through the problem-specific \texttt{apply} method. Each problem contains it's own inherited BC class, \\
	e.g. \texttt{class ThermalConvectionBoundaryCondition:public BoundaryCondition}. The apply method can override its parent's \texttt{apply} and can customize \texttt{bc} specifications tailored to the problem. E.g. reflecting/outflow/inflow... boundary conditions at either endpoint (or write one yourself!)   
		
		\item This boundary shape array, along with the appropriate number of conserved variables and the geometry are passed into this \textbf{mesh data constructor}: \texttt{auto md = std::make\_shared<MeshData> (mg->cellsShape(), bs, cl->getNumConserved());}, which initializes the mesh on which numerical simulations will be done. It's important for the program to know how many conserved variables there are to allocate the right amount of memory for the mesh/primitive arrays.		
		
	\end{itemize}
	
	
	\item Scheduler and logger are pointers passed into \texttt{maraMainLoop} in Mara.cpp. Scheduler arranges tasks to be performed in sequence and logger cout's essential output when simulation run. 
	
	\item The writer then writes the data before returning maraMainLoop.
	
	\item Logger is for performing \texttt{std::cout} into our console 
	
	\item The program file ends with: \texttt{return maraMainLoop (status, timestep, condition, advance, *scheduler, *logger)}, the first 4 arguments are callback lambdas defined above in the program and the last two are dereferenced scheduler and logger pointers which allow allocated memory to persist in between loop.
	
	\item \texttt{maraMainLoop} loops over time and advances the simulation forward in time according to \texttt{advance} lambda and exits when \texttt{condition} lambda becomes false.
	
	\item \underline{A common misconception} is to think that program files do all the heavy-lifting computations in one file. Instead, the iterations forward in time is done when the program file returns to Mara.cpp, where computations are advanced until simulations are completed. The time-step integrator can be specified in the individual program files through \texttt{ss=std::make\_shared<MethodOfLinesTVD>} member functions. (\texttt{ss} short for solution scheme). Important \texttt{ss} member function include \texttt{ss->setBoundaryCondition(bc) and ss->setRungeKuttaOrder(2)} for starters. And a few important housekeeping member functions to ensure the correct mesh and field operator are specified \texttt{ss->setMeshOperator(mo); ss->setFieldOperator(fo)}.

\end{itemize}

Now that we've covered the basic flow of the program, we can delve deeper into the details of Cow and Mara modules and its syntax.

\section{Review on Cow}
\subsection{Array}

There are a few important \texttt{Cow} classes that will be reviewed in this section. Under each section, important `\texttt{using} statements' are also listed since they sometimes could be hard to remember:

\begin{itemize}
	\item \texttt{Cow::Shape3D}
	\begin{itemize}
		\item \texttt{using Shape=std::array<int,5>;} 
		\item One has to first distinguish between a 5 component array and a 5 dimension array. 5 component array is a 1 dimensional array (vector) that looks like \texttt{\{1,2,3,4,5\}}; on the other hand, a 5 dimension array is something like \texttt{A[][][][][]}
		\item \texttt{Shape3D} is a helper class to make sure 3 component arrays return 5 component arrays
		\item \texttt{class Shape3D} is a specific case of the Shape object we discussed. \texttt{Shape3D} contain methods that focus on the first 3 components of a Shape array, which has 5 components. \texttt{Shape3D} literally focuses on axes 0, 1 and 2 which in Cartesian coordinates is x, y and z. 
		\item Important features of \texttt{Shape3D} include the ability to initialize a 5 component array that represents a 5 dimension array via only passing in the first 3 numbers of a \texttt{Shape} array, which represents the gridpoints of the first 3 dimensions. This is given by the method: \texttt{Shape3D::Shape3D (int n1, int n2, int n3)}
		\item If you don't want to be lazy, you can put in the whole 5 component \texttt{Shape} array, which is what this method allows: \texttt{Shape3D::Shape3D (Shape S)}. What this method does is the private variable \texttt{S} defined in the \texttt{class Shape3D} is filled with the individual components of the \texttt{Shape S} array passed.	
		\item \texttt{void Shape3D::deploy(std::function<void(int i,int j,int k)> function) const} is a useful way of filling an array with function(i,j,k) without looping over 3-spatial axes. Shorthand for writing a triple for-loop in C++ and useful when trying to evaluate a function over a 3D grid.
	\end{itemize}
	\item \texttt{Cow::Array}
	\begin{itemize}
		\item \texttt{using using Array=Cow::Array}
		\item \texttt{Array} constructors can take in \texttt{Shape}
		\item \texttt{Array} constructors can take 5 numbers: \texttt{\{n1, n2, n3, n4, n5\}}, each representing the number of points in each dimension of the 5 dimensional array which will be created. Cow then computes \texttt{n1*n2*n3*n4*n5*sizeof(double)} and allocates that in memory.
		\item Important note: if \texttt{Array \{\{100,1,1,5,1\}\}}, then \texttt{Array.size()}=100*1*1*5*1=500, which is the total number of cells allocated in memory.
		\item Some useful short-hand: \texttt{P(i,j,k,q,l)} will get direct access to the memory of a 5-dimensional (nested) array at \texttt{P[i][j][k][q][l]}
		\item if \texttt{P(i,j,k)} then get direct access to \texttt{P(i,j,k,0,0)}
		\item The notation to initialize \texttt{Cow::Array} is \texttt{\{\{n1,n2,n3,n4,n5\}\}}, where \texttt{n1,n2,n3} are dimenions (of a grid usually) in direction 1,2 and 3 of your system. \texttt{n4} is usually the number of primitives/conserved variables your system has. In classical hydrodynamics, \texttt{n4=5}. \texttt{n5} is the so-called rank, which tells us for each primitive variable at a point on a mesh, how many components that primitive variable has. For Newtonian hydrodynamics rank is 1 since mass density/ total energy density is a scalar function and momentum1 density is also a scalar since we split each direction up into 3 equations, so \texttt{n5=1}. One can contrast that with EM fields where rank=3 since 3 components of EM field is used to describe one primitive locally at one meshpoint.
		\item Now to apply this idea of a 5 dimensional array, as mentioned above, since numComponent in our hydrodynamic case in \texttt{ThermalConvection.cpp} is 5. If location \texttt{i,j,k} are specified within the grid, then P(i,j,k,0-4,0) contain the 5 primitive variables and is a 5 component 1D array (or a vector) corresponding to the primitive in at cell:i,j,k.
		\item \texttt{P[some\_Region]} is how one references/retrieves information from an array, where region contains strided region (discussed below).
		\item \texttt{begin()} and \texttt{end()} methods works for \texttt{Array}, and gives iterator taking into account strides since region is specified.
		

	\end{itemize}
	\item \texttt{Cow::Region}
	\begin{itemize}
		\item \texttt{using Index=std::array<int,5>;}
		\item Empty region has no stride: lower=0, upper=0, stride=0. lower and upper are respectively the lower and upper index of a region. It can be positive or negative. Positive means it's an absolute region, negative or zero means index from that end (python-like notation when dealing with arrays). 
		\item A natural region has stride 1: lower=0, upper=0, stride=1.
		\item A region literally describes a region with lower,upper,stride within an array, that's why this concept is natural. It is also important to consider stride, lower and upper because of how memory is allocated. 
		\item One useful method in Array class is Array[Region] which returns a reference to the region you specified
	\end{itemize}
	\item \texttt{Cow::Range}
	\begin{itemize}
		\item Like a 1-dimensional analog of Region where only concerned with 1 axis within an array

	\end{itemize}
\end{itemize}

\section{Mara}
Next we will discuss some useful features of Mara that will help with everyday computation:

\subsection{Mara}
We've discussed some important features of the Mara.cpp file, now let's examine the header file which contains all of the useful abstract class definitions and virtual functions ready to be overridden. 

The header file also contains detailed commenting regarding the uses of each class and method. The goal of virtual functions are used here is because we want to establish parent-child relationship to allow for overloading/overriding of methods to ensure maximum flexibility. Some important definition `\texttt{using} statements' will also be included. We'll examine a few important abstract parent classes here:

\begin{itemize}
	\item \texttt{ConservationLaw}
	\begin{itemize}
		\item \texttt{using StateArray = std::array<double, MARA\_NUM\_FIELDS>;}
		\item \texttt{ConservationLaw::State} is defined here, which is a \texttt{struct} containing arrays like primtive, conserved, flux, eigenvalues. This class will be inherited/expanded by the \texttt{ConservationLaw.cpp}.
		\item ConservationLaw::Request is also defined here which contains simple data retrieval (get methods) such as getPrimitive or getConserved from a ConservationLaw::State; these are fleshed out in ConservationLaw.cpp
	\end{itemize}
	\item \texttt{BoundaryCondition}
	\begin{itemize}
		\item \texttt{enum class MeshLocation \{ vert, edge, face, cell \};}
		\item \texttt{enum class MeshBoundary \{ left, right \};}
	
		\item The bread and butter of boundary condition is the \texttt{virtual void apply (Cow::Array\& A, MeshLocation location, MeshBoundary boundary, int axis, int numGuard) const = 0;}.
	\end{itemize}
	
	
	
	
	
	

\end{itemize}


\subsection{MeshData}
This is a section 

\subsection{BoundaryConditions}
\begin{itemize}
	\item advance takes meshdata and dt from ss
	\item ss->setboundarycondition sets bc
	\item each set of the advance process, boundary condition is applied through meshdata applyboundarycondition using applsimple
	\item applysimple uses apply 
	\item apply method in TC overrides the virtual method in the parent class
\end{itemize}

\subsection{ConservationLaws}
The \texttt{ConservationLaw.h} file contains different classes tailored to different conservation laws examined. A commonly used one is \texttt{class NewtonianHydro : public ConservationLaw} which you can tell inherits publicly from the parent \texttt{class ConservationLaw} from \texttt{Mara.h}. 

As you can see, this module provides specific implementation of the virtual methods defined in Mara's header file. Examples include \texttt{  int getNumConserved() const override;}, a function to get the number of conserved variables which would vary from 5 to 8 when one goes from Newtonian hydrodynamics to MHD. 
\begin{itemize}
\item Moving on to \texttt{ConservationLaw.cpp}, we see right off the bat, primitive names such as \texttt{\#define RHO 0} are set to an array index to facilitate data retrieval later. This is given a fancy name called fieldIndex. Be on the lookout for this in functions like \texttt{std::string NewtonianHydro::getPrimitiveName (int fieldIndex) const}.

\item Remember Conservation::State is defined in Mara.h, where it is a struct containing primitive/conserved arrays? It is used for example in \texttt{ConservationLaw::State NewtonianHydro::fromPrimitive (const Request\& request, const double* P) const}. 

\item The request (see \texttt{ConservationLaw::Request} defined in \texttt{Mara.h}) and a primitive array \texttt{P} are passed into the function. 

\item A \texttt{State S} is generated, and populated with primitives and conserved variables contained within the input array P. First off, we know mass density, 3 components of velocity and Pressure: $\rho$, $v_1$, $v_2$, $v_3$, $P$ comprise the primitive vector (5 component vector). Each one is given an index defined at the top of this file. This function takes these variables and generates conserved ones: $\rho \rightarrow \rho$, $v_1 \rightarrow	\rho v_1$. E.g. in the \texttt{.cpp} file, the \texttt{State S}'s momentum flux in direction 1: \texttt{S.U[S11] = P[RHO] * P[V11]}. Eigenvalues of the characteristics are also stored in this state. For Newtonian hydro, we know there are 3 distinct ones $\{v-c,v,v+c\}$, where c is the speed of sound.

\item An important function here are the diagnostic tools. One can use them to plot time series of mass, total energy to check the code's consistency. One example is the \texttt{ std::vector<double> NewtonianHydro::makeDiagnostics (const State\& state) const}, which you will need to pass a ConservationLaw::State in. The function creates an empty vector (of any size you want since it can contain as many diagnostics as you want), and it populates this vector with conserved variables.

The function is instrumental when trying to compute a time series of a volume-integrated variable. One thing of note is that this function represents the conserved variables within a particular cell, since volume-integrated quantities within a cell (defined as celld in \texttt{FieldOperator.cpp}):

$\texttt{diagnostics}=\int\limits_{\text{cell}} \left[\begin{smallmatrix}
	\rho \\
	\rho v_1 \\
	\rho v_2 \\
	\rho v_3 \\
	\frac{1}{2}\rho v^2 + \frac{P}{\gamma - 1}  
\end{smallmatrix} \right] dV$

 
\end{itemize}
 
\subsection{FieldOperator}
\begin{itemize}
	\item \texttt{FieldOperator} methods operate on the primitive/conserved variables. This module includes simple convenience functions like \texttt{getConservationLaw()} which returns a shared pointer to the conservation law used. 
	\item Other convenience functions include converting primitive variable arrays into conserved variables via \texttt{void generateConserved (Array::Reference P, Array::Reference U) const} which takes an array containing primitives P and puts the conserved variables into an empty array U. 
	\item One of the more important functions is getCourantTimeStep() and is computed here as well. \textbf{generateConserved(), getCourantTimeStep()}
	\item As mentioned in the previous subsection. An important diagnostic tool for sanity-checking the evolution of density-like thermodynamic quantities (i.e. entropy or total energy $e_T=e+\frac{1}{2}\rho v^2$, $e$ is the internal energy per unit volume) or momentum density in 3 dimensions $\rho \vec{v}$ in the Euler equations, is the \texttt{std::vector<double> volumeIntegratedDiagnostics (Array::Reference P, Array::Reference V) const} function. This returns volume integral (not volume average) of named diagnostics which are defaulted to `total\_energy' or 'mass' but one can customize this to ensure code is giving sensible results, \textbf{P and V contain primitives and cell volume for individual grid cells respectively throughout the whole mesh.} 
	\item \texttt{auto Treg = P.getRegion().withStride (3, law->getNumConserved())}. \texttt{Treg} is array P's region taking into account the stride. Recall that P is a 5 dimensional array, \texttt{withStride} here takes axes 3 (the number of components in a primitive vector) and sets that number to the number of conserved variables. This is to ensure we're getting the right primitive values.
	\item \texttt{Preg} is just the P array after taking into account the strided region of consideration.
	\item \texttt{pit} and \texttt{vit} represent pointer/iterators to these primitive vectors and cell volume of a particular cell; as the iterator is incremented by 1, we move to the next cell.
	\item  \texttt{celld = law->makeDiagnostics (state)} is what we described in the previous section and is a 5 component vector containing conserved variables at a particular cell location. 
	\item  This part: \texttt{diagnostics[n] += celld[n] * Vol} is looped over all the cells, hence summing the integrated to find the volume-integrated conserved variable of the whole mesh:
$$\text{Total diagnostic variable returned =} \sum_{\text{over mesh}} \texttt{diagnostics}$$
\end{itemize}

\subsection{MeshOperator}
\begin{itemize}
	\item Mesh operators are operators which Mara performs on the mesh grid itself (just spatial dimensions, doesn't touch primitive/conserved data in each cell). Common member functions include \texttt{divergence} and {curl}. One important one is \texttt{measure}, which returns the 1, 2, or 3 dimensional measure of the given mesh locations: length of edges, area of faces, or volume of cells. \textbf{ Can talk about generate or generate Sourceterms HERE!!!!!!!!!!!}
\end{itemize}

\subsection{Scheduler}
\begin{itemize}
	\item Scheduler and logger are pointers that are passed through back into the maraMainLoop in the Mara.cpp file. Main function of scheduler is to put together a list of tasks to be completed at certain points when the code runs. They could include writing checkpoints or saving down time series data to ensure code is running properly and thereby optimizing data retrieval. An example of scheduler is \texttt{scheduler->schedule (taskTimeSeries, TaskScheduler::Recurrence (user["tsi"]), "time\_series");}. \texttt{taskTimeSeries} is a callback lambda which the function takes as input, thereby telling the scheduler what function to use to perform a specific task at certain periods of time during runtime. What determines \emph{when} the task is performed depends solely on the \textbf{recurrence rule}. This literally means, when will the task/function recurr in the program via some hard and fast rule. In this case, \texttt{TaskScheduler::Recurrence (user["tsi"])} does just that using \texttt{user["tsi"]} which is specified at runtime. \textbf{SPLIT LOGGER INTO SEPARATE PARAGRAPH}
\end{itemize}


\subsection{Problems}
This is a section 

\subsection{RiemannSolvers}
This is a section 

\subsection{SolutionSchemes}
This is a section 









\end{document}